This is dswm.info, produced by makeinfo version 4.13 from dswm.texi.

INFO-DIR-SECTION X11
START-INFO-DIR-ENTRY
* DSWM: (dswm).       A Common Lisp window manager
END-INFO-DIR-ENTRY

   This is the Deep Space Window Manager user manual.

   Copyright (C) 2000-2008 Shawn Betts

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "Copying" and "GNU General Public License"
are included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: dswm.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

   This document explains how to use The Deep Space Window Manager.

* Menu:

* Introduction::
* Key Bindings::
* Commands::
* Message and Input Bar::
* Windows::
* Frames::
* Mode-line::
* Groups::
* Screens::
* Interacting With Unix::
* Interacting With X11::
* Miscellaneous Commands::
* Colors::
* Hooks::
* Modules::
* Hacking::
* Command and Function Index::
* Variable Index::

 --- The Detailed Node Listing ---

Introduction

* Starting DSWM::
* Basic Usage::
* Interacting with the Lisp process::
* Contact the DSWM developers::

Key Bindings

* List of Default Keybindings::
* Binding Keys::
* Modifiers::

Message and Input Bar

* Customizing The Bar::
* Using The Input Bar::
* Programming The Message Bar::
* Programming the Input Bar::

Windows

* Window Marks::
* Customizing Window Appearance::
* Controlling Raise And Map Requests::
* Programming With Windows::
* Rule Based Window Placement::

Frames

* Interactively Resizing Frames::
* Frame Dumping::

Groups

* Customizing Groups::

Screens

* Xinerama::
* Programming With Screens::

Miscellaneous Commands

* Menus::
* DSWM's Data Directory::
* Debugging DSWM::
* Timers::
* Getting Help::

Colors

* Behind The Scenes Look At Colors::

Hacking

* General Advice::
* Using git with DSWM::
* Sending Patches::


File: dswm.info,  Node: Introduction,  Next: Key Bindings,  Prev: Top,  Up: Top

1 Introduction
**************

DSWM is an X11 window manager written entirely in Common Lisp. Its user
interface goals are similar to ratpoison's but with an emphasis on
customizability, completeness, and cushiness.

* Menu:

* Starting DSWM::
* Basic Usage::
* Interacting with the Lisp process::
* Contact the DSWM developers::


File: dswm.info,  Node: Starting DSWM,  Next: Basic Usage,  Prev: Introduction,  Up: Introduction

1.1 Starting DSWM
=================

There are a number of ways to start DSWM but the most straight forward
method is as follows. This assumes you have a copy of the DSWM source
code and are using the `SBCL' Common Lisp environment.

  1. Install `sbcl', the `portable-clx' package, and `cl-ppcre'. In
     Debian, `portable-clx' is the `cl-clx-sbcl' package. You can also
     use `asdf-install' to download and install `clx':

          $ sbcl
          * (require :asdf)
          * (require :asdf-install)
          * (asdf-install:install :clx)
          * (asdf-install:install :cl-ppcre)

     Note that `asdf-install' requires `gnupg'.

  2. In the `dswm' directory, run `./configure'.

  3. run `make'. If all goes well, this should create a `dswm'
     executable.

  4. In your `~/.xinitrc' file include the line `/path/to/dswm'.
     Remember to replace `/path/to/' with the actual path.

  5. Finally, start X windows with `startx'. Cross your fingers. You
     should see a `Welcome To the Deep Space Window Manager' message
     pop up in the upper, right corner. At this point, you have
     successfully started DSWM.


File: dswm.info,  Node: Basic Usage,  Next: Interacting with the Lisp process,  Prev: Starting DSWM,  Up: Introduction

1.2 Basic Usage
===============

Once you have DSWM up and running, the first thing you might want to do
is start `emacs'. Type `C-t e', or in other words `Control + t'
followed by `e'. Now perhaps you want an `xterm'. Type `C-t c'. Now you
have some programs running.

   To see a list of windows DSWM is managing, type `C-t w'. The
highlighted window is the one you're looking at right now. It's the
focused window.

   All of DSWM's keys are bound to named commands, which can be
executed not only by keys but also from the input bar. Type `C-t ;' to
open a command prompt. Now type `time' and press return. Note, `time'
can also be called by typing `C-t a'.  Throughout this manual you'll
find definitions for commands, functions, and variables. Any command
you see in this manual can be executed from the input bar or bound to a
key.

   At this point you probably want to switch back from your new `xterm'
to `emacs'. Type `C-t C-t'. This runs the `other' command. Type it
again and you're back to xterm.

   Perhaps you'd like to see `emacs' and `xterm' side-by-side. Type
`C-t s'. You have now split the screen into 2 `frames'. For more
information see *note Frames::. To switch to the empty frame type `C-t
TAB'. Now let's pull the xterm window into this empty frame. Type `C-t
w' for a window listing. Find the `xterm' window. See the number beside
it? Type `C-t' followed by `xterm''s window number.

   Another common activity is browsing the interwebs. Type `C-t !'.
The input bar pops up again. You can now run a shell command.  Let's
start a web browser: type `firefox' into the input bar and press return.

   Unfortunately, `firefox' probably isn't wide enough because it's in
one of the frames. Type `C-t Q' to remove all frames but the current
one and resize it to fit the screen.

   For a full list of key bindings, see *note List of Default
Keybindings::.


File: dswm.info,  Node: Interacting with the Lisp process,  Next: Contact the DSWM developers,  Prev: Basic Usage,  Up: Introduction

1.3 Interacting with the Lisp process
=====================================

Since DSWM is a Lisp program, there is a way for you to evaluate Lisp
code directly, on the same Lisp process that DSWM is running on.  Type
`C-t :' and an input box will appear. Then type some Lisp expression.

   When you call `eval' this way, you will be in the DSWM-USER package,
which imports all the exported symbols from the main DSWM package.

`*mode-line-border-width*'
     Reads the value of *MODE-LINE-BORDER-WIDTH*.

`(setf *mode-line-border-width* 3)'
     Sets the variable *MODE-LINE-BORDER-WIDTH* to 3.

`(set-prefix-key (kbd "C-M-H-s-z"))'
     Calls the `set-prefix-key' function (and sets a new keyboard
     prefix)


File: dswm.info,  Node: Contact the DSWM developers,  Prev: Interacting with the Lisp process,  Up: Introduction

1.4 Contact the DSWM developers
===============================

The DSWM home page is `http://dswm.nongnu.org/'.

   You can reach Shawn Betts at <sabetts at vcn.bc.ca>.

   The DSWM mailing list is <dswm-devel@nongnu.org> which you can
subscribe to at `http://mail.nongnu.org/mailman/listinfo/dswm-devel'.
Posting is restricted to subscribers to keep spam out of the archives.

   The DSWM IRC channel can be found on Freenode at `#dswm'
(irc://irc.freenode.net/#dswm).


File: dswm.info,  Node: Key Bindings,  Next: Commands,  Prev: Introduction,  Up: Top

2 Key Bindings
**************

DSWM is controlled entirely by keystrokes and Lisp commands. It mimics
GNU Screen's keyboard handling. DSWM's default prefix key is `C-t'.

* Menu:

* List of Default Keybindings::
* Binding Keys::
* Modifiers::


File: dswm.info,  Node: List of Default Keybindings,  Next: Binding Keys,  Prev: Key Bindings,  Up: Key Bindings

2.1 List of Default Keybindings
===============================

The following is a list of keybindings.

`C-t D'
     Select the window with the corresponding digit D

`C-t C-D'
     Pull the window with the corresponding digit D into the current
     frame

`C-t n'
`C-t C-n'
`C-t Space'
     Go to the next window in the window list

`C-t p'
`C-t C-p'
     Go to the previous window in the window list

`C-t ''
     Go to a window by name

`C-t "'
     Select a window from a list and focus the window.

`C-t C-g'
     Abort the current command. This is useful if you accidentally hit
     `C-t'

`C-t w'
     List all the windows

`C-t i'
     Display information about the current window.

`C-t f'
     Select a frame by number

`C-t s'
     Split current frame vertically

`C-t S'
     Split current frame horizontally

`C-t k'
`C-t C-k'
     Sends a kill message to the current frame and the running program.

`C-t K'
     Kills the current frame and running program; like a `kill -9'.

`C-t c'
`C-t C-c'
     Run an X terminal; by default `xterm'

`C-t e'
`C-t C-e'
     Run Emacs or raise it if it is already running.

`C-t t'
     Sends a `C-t' to the frame; this is useful for applications like
     Firefox which make heavy use of `C-t' (in Firefox's case, for
     opening a new tab). This is similar to how GNU screen uses `C-a a'.

`C-t w'
`C-t C-w'
     Prints out a list of the windows, their number, and their name.

`C-t b'
`C-t C-b'
     Banish the mouse point to the lower right corner of the screen.

`C-t a'
`C-t C-a'
     Display the current time and date, much like the Unix command
     `date'.

`C-t C-t'
     Switch to the last window to have focus in the current frame.

`C-t !'
     Prompt for a shell command to run via `/bin/sh'. All output is
     discarded.

`C-t R'
     If the screen is split into multiple frames, one split will be
     undone. If there is only one split, the effect will be the same as
     `C-t Q'.

`C-t o'
`C-t TAB'
     If the screen is split into multiple frames, focus shifts to the
     `next' frame, where it cycles to the right and then down; analogous
     to `C-x o' in Emacs.

`C-t F'
     Display "Current Frame" in the frame which has focus.

`C-t ;'
     Opens the input box. DSWM commands can be run from here, and the
     input history moved through.

`C-t :'
     Opens the input box, but all things typed in here will be sent to
     the Common Lisp interpreter where they will be ran as Lisp
     programs; thus, input should be valid Common Lisp.

`C-t C-h'
`C-t ?'
     The help.

`C-t -'
     Hide all frames and show the root window.

`C-t Q'
     Removes all splits and maximizes the frame with focus.

`C-t Up'
`C-t Down'
`C-t Left'
`C-t Right'
     Shift focus to an adjacent frame in the specified direction. `C-t
     Up' will shift focus up, if possible, `C-t Down' will shift
     downwards, etc.

`C-t v'
     Prints out the version of the running DSWM.

`C-t #'
     Toggle the mark on the current window

`C-t m'
`C-t C-m'
     Display the last message. Hitting this keybinding again displays
     the message before that, and so on.

`C-t l'
`C-t C-l'
     redisplay the current window and force it to take up the entire
     frame.

`C-t G'
     Display all groups and windows in each group. For more information
     see *note Groups::.

`C-t FN'
     Jump to the corresponding group N. `C-t F1' jumps to group 1 and
     so on.

`C-t g g'
     Show the list of groups.

`C-t g c'
     Create a new group.

`C-t g n'
`C-t g C-n'
`C-t g SPC'
`C-t g C-SPC'
     Go to the next group in the list.

`C-t g N'
     Go to the next group in the list and bring the current window
     along.

`C-t g p'
`C-t g C-p'
     Go to the previous group in the list.

`C-t g P'
     Go to the previous group in the list and bring the current window
     along.

`C-t g ''
     Select a group by name or by number.

`C-t g "'
     Select a group from a list and switch to it.

`C-t g m'
     Move the current window to the specified group.

`C-t g k'
     Kill the current group. All windows are merged into the next group.

`C-t g A'
`C-t g r'
     Change the current group's name.

`C-t g D'
     Go to the group with digit D. `C-t g 1' jumps to group 1 and so on.

`C-t +'
     Make frames the same height or width in the current frame's
     subtree.

`C-t h k'
     Describe the specified key binding.

`C-t h f'
     Describe the specified function.

`C-t h v'
     Describe the specified variable.

`C-t h w'
     List all key sequences that are bound to the specified command

`C-t h c'
     Describe the specified command.


File: dswm.info,  Node: Binding Keys,  Next: Modifiers,  Prev: List of Default Keybindings,  Up: Key Bindings

2.2 Binding Keys
================

@ define-key @ undefine-key @ kbd !!! set-prefix-key

   @ make-sparse-keymap

   ### *root-map* ### *top-map* ### *groups-map*

   !!! bind


File: dswm.info,  Node: Modifiers,  Prev: Binding Keys,  Up: Key Bindings

2.3 Modifiers
=============

Many users have had some difficulty with setting up modifiers for DSWM
keybindings. This is caused by a combination of how DSWM handles
modifiers and the default modifiers list for many users' X servers.

   * My "Super" key doesn't work!

     This is most likely caused by having the Hyper and Super keys
     listed as the same modifier in the modifier list.

          $ xmodmap
          xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

          shift       Shift_L (0x32),  Shift_R (0x3e)
          lock        Caps_Lock (0x42)
          control     Control_L (0x25),  Control_R (0x6d)
          mod1        Alt_L (0x40),  Alt_R (0x71),  Meta_L (0x9c)
          mod2        Num_Lock (0x4d)
          mod3
          mod4        Super_L (0x7f),  Hyper_L (0x80)
          mod5        Mode_switch (0x5d),  ISO_Level3_Shift (0x7c)

     The problem is in the line beginning with "mod4". The way to set up
     the modifier list correctly is to have just the Super key as the
     mod4 modifier. The following `xmodmap' commands will do just that.

          # clear out the mod4 modifier
          $ xmodmap -e 'clear mod4'
          $ xmodmap
          xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

          shift       Shift_L (0x32),  Shift_R (0x3e)
          lock        Caps_Lock (0x42)
          control     Control_L (0x25),  Control_R (0x6d)
          mod1        Alt_L (0x40),  Alt_R (0x71),  Meta_L (0x9c)
          mod2        Num_Lock (0x4d)
          mod3
          mod4
          mod5        Mode_switch (0x5d),  ISO_Level3_Shift (0x7c)

          # add Super as a mod4 modifier
          $ xmodmap -e 'add mod4 = Super_L'
          $ xmodmap
          xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

          shift       Shift_L (0x32),  Shift_R (0x3e)
          lock        Caps_Lock (0x42)
          control     Control_L (0x25),  Control_R (0x6d)
          mod1        Alt_L (0x40),  Alt_R (0x71),  Meta_L (0x9c)
          mod2        Num_Lock (0x4d)
          mod3
          mod4        Super_L (0x73),  Super_L (0x7f)
          mod5        Mode_switch (0x5d),  ISO_Level3_Shift (0x7c)

     You can automate this by storing the commands in a file and calling
     xmodmap when you start your X session.

          $ cat ~/.Xmodmap
          clear mod4
          add mod4 = Super_L

     If you use `startx', modify your `~/.xsession' or `~/.xinitrc'
     file.

          $ cat ~/.xsession
          #!/bin/sh

          xmodmap ~/.Xmodmap
          exec /usr/bin/dswm

     If you use a graphical login manager (GDM, KDM, etc.), your
     `~/.Xmodmap' file should be fed to `xmodmap' when you log in.
     FIXME: verify this.

   * Handling Meta and Alt: when do I use `M-' and `A-'?

     If you have no Meta keys defined (see the output of the `xmodmap'
     command), then DSWM will treat the `M-' prefix in keybindings to
     mean Alt. However, if there are Meta keys defined, then the `M-'
     prefix refers to them, and the `A-' prefix refers to Alt.

     Most users will simply use `M-' to refer to their Alt keys.
     However, users that define separate Meta and Alt keys will use
     `M-' to refer to the former, and `A-' to refer to the latter.

   * How can I set up a Hyper key and use it with DSWM?

     To set up a Hyper key, you need to do two things: bind a physical
     key to be a Hyper key, and add that key to the modifiers list.

     The following example shows how to bind the control key at the
     bottom-left of most keyboards to be Hyper. This is useful if you've
     made Caps Lock into a control key, and have no use for the
     bottom-left key.

          $ xmodmap -e 'keycode 37 = Hyper_L'
          $ xmodmap -e 'clear mod5'
          $ xmodmap -e 'add mod5 = Hyper_L'

     To use a different key for Hyper, replace the keycode "37" above.
     Use the `xev' program to see the keycode that any physical key has.
     Refer to the section above on setting up the Super key to see how
     to automate setting the Hyper key when you start X.

     Now you can use `H-' as a prefix in DSWM bindings.

          (define-key *top-map* (kbd "H-RET") "fullscreen")
          (define-key *top-map* (kbd "H-Left") "gprev")
          (define-key *top-map* (kbd "H-Right") "gnext")
          (define-key *top-map* (kbd "H-TAB") "other")

     Since essentially no programs have Hyper bindings, you can safely
     bind commands to the *TOP-MAP*.



File: dswm.info,  Node: Commands,  Next: Message and Input Bar,  Prev: Key Bindings,  Up: Top

3 Commands
**********

If you've used emacs before you'll find commands and functions
familiar. Commands are functions that can be bound to keys and executed
interactively from DSWM's input bar. A command expects a certain number
of arguments and any that are not supplied will be prompted for.

   FIXME: actually write some docs here


File: dswm.info,  Node: Message and Input Bar,  Next: Windows,  Prev: Commands,  Up: Top

4 Message and Input Bar
***********************

!!! echo !!! colon

* Menu:

* Customizing The Bar::
* Using The Input Bar::
* Programming The Message Bar::
* Programming the Input Bar::


File: dswm.info,  Node: Customizing The Bar,  Next: Using The Input Bar,  Prev: Message and Input Bar,  Up: Message and Input Bar

4.1 Customizing The Bar
=======================

The bar's appearance and behavior can be modified with the following
functions and variables.

   @ set-fg-color @ set-bg-color @ set-border-color @
set-msg-border-width @ set-font

   ### *message-window-padding* ### *message-window-gravity* ###
*timeout-wait* ### *input-window-gravity*


File: dswm.info,  Node: Using The Input Bar,  Next: Programming The Message Bar,  Prev: Customizing The Bar,  Up: Message and Input Bar

4.2 Using The Input Bar
=======================

The following is a list of keybindings for the Input Bar. Users of Emacs
will recognize them.

`DEL'
     Delete the character before point (`delete-backward-char').

`M-DEL'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

`C-d'
`Delete'
     Delete the character after point (`delete-forward-char').

`M-d'
     Kill forward to the end of the next word (`forward-kill-word').

`C-f'
`Right'
     Move forward one character (`forward-char').

`M-f'
     Move forward one word (`forward-word').

`C-b'
`Left'
     Move backward one character (`backward-char').

`M-b'
     Move backward one word (`backward-word').

`C-a'
`Home'
     Move to the beginning of the current line
     (`move-beginning-of-line').

`C-e'
`End'
     Move to the end of the current line (`move-end-of-line').

`C-k'
     Kill to the end of the line (`kill-line').

`C-u'
     Kill to the beginning of the line (`kill-to-beginning'), the same
     as `C-a C-k'.

`C-p'
`Up'
     Move to the next earlier entry saved in the command history
     (`history-back').

`C-n'
`Down'
     Move to the next later entry saved in the command history
     (`history-forward').

`RET'
     Submit the entered command (`submit').

`C-g'
     Abort the current action by closing the Input Bar (`abort').

`C-y'
     Paste text from clipboard into the Input Bar (`yank-selection').

`TAB'
     Clockwise tab complete the current string, if possible. Press
     `TAB' again to cycle through completions.

`S-TAB'
     Counter-clockwise tab complete the current string, if possible.
     Press `S-TAB' again to cycle through completions.



File: dswm.info,  Node: Programming The Message Bar,  Next: Programming the Input Bar,  Prev: Using The Input Bar,  Up: Message and Input Bar

4.3 Programming The Message Bar
===============================

@ echo-string @ message ### *input-history-ignore-duplicates* !!!
copy-last-message


File: dswm.info,  Node: Programming the Input Bar,  Prev: Programming The Message Bar,  Up: Message and Input Bar

4.4 Programming the Input Bar
=============================

New input behavior can be added to the input bar by creating editing
functions and binding them to keys in the *INPUT-MAP* using
`define-key', just like other key bindings.

   An input function takes 2 arguments: the input structure and the key
pressed.

   @ read-one-line @ read-one-char @ completing-read @
input-insert-string @ input-insert-char

   ### *input-map*


File: dswm.info,  Node: Windows,  Next: Frames,  Prev: Message and Input Bar,  Up: Top

5 Windows
*********

!!! next !!! pull-hidden-next !!! prev !!! pull-hidden-previous !!!
delete-window !!! kill-window !!! echo-windows !!! other-window !!!
pull-hidden-other !!! renumber !!! meta !!! select-window !!!
select-window-by-number !!! title !!! windowlist !!! fullscreen !!! info
!!! refresh !!! redisplay

   ### *window-format* ### *window-name-source* ###
*new-window-prefered-frame*

* Menu:

* Window Marks::
* Customizing Window Appearance::
* Controlling Raise And Map Requests::
* Programming With Windows::
* Rule Based Window Placement::


File: dswm.info,  Node: Window Marks,  Next: Customizing Window Appearance,  Prev: Windows,  Up: Windows

5.1 Window Marks
================

Windows can be marked. A marked window has a # beside it in the window
list. Some commands operate only on marked windows.

   !!! mark !!! clear-window-marks !!! pull-marked


File: dswm.info,  Node: Customizing Window Appearance,  Next: Controlling Raise And Map Requests,  Prev: Window Marks,  Up: Windows

5.2 Customizing Window Appearance
=================================

### *maxsize-border-width* ### *transient-border-width* ###
*normal-border-width* ### *window-border-style*

   @ set-win-bg-color @ set-focus-color @ set-unfocus-color @
set-normal-gravity @ set-maxsize-gravity @ set-transient-gravity

   !!! gravity


File: dswm.info,  Node: Controlling Raise And Map Requests,  Next: Programming With Windows,  Prev: Customizing Window Appearance,  Up: Windows

5.3 Controlling Raise And Map Requests
======================================

It is sometimes handy to deny a window's request to be focused. The
following variables determine such behavior.

   A map request occurs when a new or withdrawn window requests to be
mapped for the first time.

   A raise request occurs when a client asks the window manager to give
an existing window focus.

   ### *deny-map-request* ### *deny-raise-request* ###
*suppress-deny-messages*

   Some examples follow.

     ;; Deny the firefox window from taking focus when clicked upon.
     (push '(:class "gecko") dswm:*deny-raise-request*)

     ;; Deny all map requests
     (setf dswm:*deny-map-request* t)

     ;; Deny transient raise requests
     (push '(:transient) dswm:*deny-map-request*)

     ;; Deny the all windows in the xterm class from taking focus.
     (push '(:class "Xterm") dswm:*deny-raise-request*)


File: dswm.info,  Node: Programming With Windows,  Next: Rule Based Window Placement,  Prev: Controlling Raise And Map Requests,  Up: Windows

5.4 Programming With Windows
============================

%%% define-window-slot

   @ window-send-string ### *default-window-name*


File: dswm.info,  Node: Rule Based Window Placement,  Prev: Programming With Windows,  Up: Windows

5.5 Rule Based Window Placement
===============================

%%% define-frame-preference @ clear-window-placement-rules

   !!! remember !!! forget !!! dump-window-placement-rules !!!
restore-window-placement-rules


File: dswm.info,  Node: Frames,  Next: Mode-line,  Prev: Windows,  Up: Top

6 Frames
********

Frames contain windows. All windows exist within a frame.

   Those used to ratpoison will notice that this differs from
ratpoison's window pool, where windows and frames are not so tightly
connected.

   !!! pull-window-by-number !!! hsplit !!! vsplit !!! remove-split !!!
only !!! curframe !!! fnext !!! sibling !!! fother !!! fselect !!!
resize !!! balance-frames !!! fclear !!! move-focus !!! move-window !!!
next-in-frame !!! prev-in-frame !!! other-in-frame !!!
echo-frame-windows !!! exchange-direction

   ### *min-frame-width* ### *min-frame-height* ### *new-frame-action*

* Menu:

* Interactively Resizing Frames::
* Frame Dumping::


File: dswm.info,  Node: Interactively Resizing Frames,  Next: Frame Dumping,  Prev: Frames,  Up: Frames

6.1 Interactively Resizing Frames
=================================

There is a mode called `iresize' that lets you interactively resize the
current frame. To enter the mode use the `iresize' command or type <C-t
r>.

   The following keybindings apply to the mode:
`C-p'
`Up'
`k'
     Shrink the frame vertically.

`C-n'
`Down'
`j'
     Expand the frame vertically.

`C-f'
`Right'
`l'
     Expand the frame horizontally.

`C-b'
`Left'
`h'
     Shrink the frame horizontally.

`C-g'
`ESC'
     Abort the interactive resize. NOTE: This currently doesn't work.

`RET'
     Select the highlighted option.


   !!! iresize !!! abort-iresize !!! exit-iresize

   ### *resize-increment*


File: dswm.info,  Node: Frame Dumping,  Prev: Interactively Resizing Frames,  Up: Frames

6.2 Frame Dumping
=================

The configuration of frames and groups can be saved and restored using
the following commands.

   !!! dump-desktop-to-file !!! dump-group-to-file !!!
dump-screen-to-file !!! restore-from-file !!! place-existing-windows


File: dswm.info,  Node: Mode-line,  Next: Groups,  Prev: Frames,  Up: Top

7 The Mode Line
***************

The mode line is a bar that runs across either the top or bottom of a
head and is used to display information. By default the mode line
displays the list of windows, similar to the output `C-t w' produces.

   Alternatively, external panel applications such as the GNOME panel
and KDE's kicker may be used. Simply starting one of these programs is
enough to set it as the mode line of the head it would like to be on
(if the panel is Xinerama aware) or whichever head is available. In
order to avoid problems displaying menus, configure your panel
application for positioning at the top or bottom of the head rather
than relying on *MODE-LINE-POSITION*

   The mode line can be turned on and off with the `mode-line' command
or the lisp function `dswm:toggle-mode-line'. Each head has its own
mode line. For example:

     ;; turn on/off the mode line for the current head only.
     (dswm:toggle-mode-line (dswm:current-screen)
                               (dswm:current-head))

   The mode line is updated after every DSWM command.

   To display the window list and the current date on the modeline, one
might do the following:

     (setf dswm:*screen-mode-line-format*
           (list "%w | "
                 '(:eval (dswm:run-shell-command "date" t))))

   `(dswm:run-shell-command "date" t)' runs the command `date' and
returns its output as a string.

   !!! mode-line

   @ toggle-mode-line

   ### *screen-mode-line-format*

   The following variables control the color, position, and size of the
mode line.

   ### *mode-line-position* ### *mode-line-border-width* 1 ###
*mode-line-pad-x* ### *mode-line-pad-y* ### *mode-line-background-color*
### *mode-line-foreground-color* ### *mode-line-border-color* ###
*mode-line-timeout*


File: dswm.info,  Node: Groups,  Next: Screens,  Prev: Mode-line,  Up: Top

8 Groups
********

Groups in DSWM are more commonly known as "virtual desktops" or
"workspaces". Why not create a new term for it?

   !!! gnew !!! gnew-float !!! gnewbg !!! gnewbg-float !!! gnext !!!
gprev !!! gnext-with-window !!! gprev-with-window !!! gother !!! gmerge
!!! groups !!! vgroups !!! gselect !!! gmove !!! gkill !!! grename !!!
grouplist

* Menu:

* Customizing Groups::


File: dswm.info,  Node: Customizing Groups,  Prev: Groups,  Up: Groups

8.1 Customizing Groups
======================

### *group-formatters* ### *group-format*

   @ current-group


File: dswm.info,  Node: Screens,  Next: Interacting With Unix,  Prev: Groups,  Up: Top

9 Screens
*********

DSWM handles multiple screens.

   !!! snext !!! sprev !!! sother

* Menu:

* Xinerama::
* Programming With Screens::


File: dswm.info,  Node: Xinerama,  Next: Programming With Screens,  Prev: Screens,  Up: Screens

9.1 Xinerama
============

DSWM will attempt to detect Xinerama heads at startup (and at no other
time.) Heads are logically contained by screens. In a dual-monitor
Xinerama configuration, there will be one screen with two heads.
Non-rectangular layouts are supported (frames will not be created in
the 'dead zone'.) And message windows will be displayed on the current
head-that is, the head to which the currently focused frame belongs.


File: dswm.info,  Node: Programming With Screens,  Prev: Xinerama,  Up: Screens

9.2 Programming With Screens
============================

@ current-screen

   @ screen-current-window

   @ current-window

   ### *screen-list*


File: dswm.info,  Node: Interacting With Unix,  Next: Interacting With X11,  Prev: Screens,  Up: Top

10 Interacting With Unix
************************

!!! run-shell-command

   @ programs-in-path @ pathname-is-executable-p

   ### *shell-program*

   @ getenv @ (setf getenv)


File: dswm.info,  Node: Interacting With X11,  Next: Miscellaneous Commands,  Prev: Interacting With Unix,  Up: Top

11 Interacting With X11
***********************

@ set-x-selection @ get-x-selection


File: dswm.info,  Node: Miscellaneous Commands,  Next: Colors,  Prev: Interacting With X11,  Up: Top

12 Miscellaneous Commands
*************************

The following is a list of commands that don't really fit in any other
section.

   !!! emacs !!! banish !!! ratwarp !!! ratrelwarp !!! ratclick !!!
echo-date !!! eval-line !!! window-send-string !!! reload !!! loadrc
!!! keyboard-quit !!! quit !!! restart-hard !!! restart-soft !!! getsel
!!! putsel !!! command-mode !!! copy-unhandled-error !!! commands !!!
lastmsg !!! list-window-properties

   @ run-commands

   %%% defcommand %%% define-dswm-type

   @ run-or-raise

   ### *run-or-raise-all-groups* ### *run-or-raise-all-screens*

   @ restarts-menu

   %%% with-restarts-menu

   ### *startup-message* ### *suppress-abort-messages* ###
*default-package*

   %%% defprogram-shortcut

   ### *initializing*

* Menu:

* Menus::
* DSWM's Data Directory::
* Debugging DSWM::
* Timers::
* Getting Help::


File: dswm.info,  Node: Menus,  Next: DSWM's Data Directory,  Prev: Miscellaneous Commands,  Up: Miscellaneous Commands

12.1 Menus
==========

Some commands present the options in a menu. The following are the menu
key bindings:

`C-p'
`Up'
`k'
     Highlight the previous menu option.

`C-n'
`Down'
`j'
     Highlight the next menu option.

`C-g'
`ESC'
     Abort the menu.

`RET'
     Select the highlighted option.



File: dswm.info,  Node: DSWM's Data Directory,  Next: Debugging DSWM,  Prev: Menus,  Up: Miscellaneous Commands

12.2 DSWM's Data Directory
==========================

If you want to store DSWM data between sessions, the recommended method
is to store them in `~/.dswm.d/'. DSWM supplies some functions to make
doing this easier.

   ### *data-dir* @ data-dir-file %%% with-data-file


File: dswm.info,  Node: Debugging DSWM,  Next: Timers,  Prev: DSWM's Data Directory,  Up: Miscellaneous Commands

12.3 Debugging DSWM
===================

### *debug-level* ### *debug-stream* @ redirect-all-output


File: dswm.info,  Node: Timers,  Next: Getting Help,  Prev: Debugging DSWM,  Up: Miscellaneous Commands

12.4 Timers
===========

DSWM has a timer system similar to that of "Emacs".

   @ run-with-timer @ cancel-timer

 -- Function: timer-p TIMER
     Return T if TIMER is a timer structure.


File: dswm.info,  Node: Getting Help,  Prev: Timers,  Up: Miscellaneous Commands

12.5 Getting Help
=================

!!! describe-key !!! describe-variable !!! describe-function !!!
where-is !!! modifiers


File: dswm.info,  Node: Colors,  Next: Hooks,  Prev: Miscellaneous Commands,  Up: Top

13 Colors
*********

All text printed by dswm is run through a coloring engine before being
displayed. All color commands start with a `^' (caret) character and
apply to all text after it.

`^0-9'
     A caret followed by a single digit number changes the foreground
     color to the specified color. A `*' can be used to specify the
     normal color. See the color listing below.

`^0-90-9'
     A caret followed by two digits sets the foreground and background
     color. The first digit refers to the foreground color and the
     second digit to the background color. A `*' can be used in place of
     either digit to specify the normal color. See the color listing
     below.

`^B'
     Turn on bright colors.

`^b'
     Turn off bright colors.

`^n'
     Use the normal background and foreground color.

`^R'
     Reverse the foreground and background colors.

`^r'
     Turn off reverse colors.

`^['
     Push the current colors onto the color stack. The current colors
     remain unchanged.

`^]'
     Pop the colors off the color stack.

`^^'
     Print a regular caret.

   The default colors are made to resemble the 16 VGA colors and are:
0 black

1 red

2 green

3 yellow

4 blue

5 magenta

6 cyan

7 white

   There are only 8 colors by default but 10 available digits. The last
two digits are left up to the user. *note Behind The Scenes Look At
Colors:: for information on customizing colors.

* Menu:

* Behind The Scenes Look At Colors::


File: dswm.info,  Node: Behind The Scenes Look At Colors,  Prev: Colors,  Up: Colors

13.1 Behind The Scenes Look At Colors
=====================================

Color indexes are stored in *COLORS* as a list. The default list of
colors leave 2 slots for the user to choose. If you'd like to use
`Papaya Whip' and `Dark Golden Rod 3' you might eval the following:

     (setf *colors* (append *colors*
                            (list "PapayaWhip"
                                  "DarkGoldenRod3")))
     (update-color-map (current-screen))

   Of course, you can change all the colors if you like.

   @ parse-color-string @ uncolorify ### *colors* @ update-color-map


File: dswm.info,  Node: Hooks,  Next: Modules,  Prev: Colors,  Up: Top

14 Hooks
********

DSWM exports a number of hooks you can use to add customizations; like
hooks in Emacs, you add to a hook with the `add-hook' function. for
example:

     (dswm:add-hook 'dswm:*new-window-hook* 'my-new-window-custos)

   adds your `my-new-window-custos' function to the list of functions
called when a new window appears.

   %%% add-hook %%% remove-hook

   The following hooks are available:

   $$$ *new-window-hook* $$$ *destroy-window-hook* $$$
*focus-window-hook* $$$ *place-window-hook* $$$ *start-hook* $$$
*internal-loop-hook* $$$ *focus-frame-hook* $$$ *new-frame-hook* $$$
*message-hook* $$$ *top-level-error-hook* $$$ *focus-group-hook* $$$
*key-press-hook* $$$ *root-click-hook* $$$ *mode-line-click-hook* $$$
*urgent-window-hook*


File: dswm.info,  Node: Modules,  Next: Hacking,  Prev: Hooks,  Up: Top

15 Modules
**********

DSWM has a growing number of modules not loaded by default. All modules
exist in the `contrib/' directory of DSWM's archive.

   !!! load-module


File: dswm.info,  Node: Hacking,  Next: Command and Function Index,  Prev: Modules,  Up: Top

16 Hacking
**********

For those of you who have worked on Free Software projects before, this
part should probably be fairly intuitive.

* Menu:

* General Advice::
* Using git with DSWM::
* Sending Patches::


File: dswm.info,  Node: General Advice,  Next: Using git with DSWM,  Prev: Hacking,  Up: Hacking

16.1 Hacking:  General Advice
=============================

  1. Pay attention to file names and contents. If you're making changes
     to mode-line related code, don't put it in `core.lisp'. If you're
     introducing some completely new featureset, consider putting all of
     the new code in a new file.

  2. Does a command need to be user-visible ("interactive") or is it
     just called by other commands?

        * If it's not going to be user-visible, you can just use the
          familiar `(defun foo () ...)' syntax.

        * If you want the command to be used interactively, you use
          DSWM's `defcommand' syntax, as in the examples below.

               (defcommand test (foo bar)
                  ((:string "How you're going to prompt for variable foo: ")
                   (:number "How you want to prompt for variable bar: "))
                  "This command is a test"
                  (body...))

               (defcommand test2 () ()
                  "This is also a test"
                  (body...))

               (defcommand title (args) (interactive-args)
                  "Doc string"
                  (body...))

          So basically, inside the first set of parentheses after the
          function name, you specify what (if any) arguments will be
          passed to the command. The second set of parentheses tells
          DSWM how to get those arguments if they're not explicitly
          passed to the command. For example,

               ((:string "What do you want to do: "))

          will read a string from the input the user provides. The
          quoted text is the prompt the user will see. Of course, if
          you were to, say, call the command test, as defined above,
          from another piece of code, it wouldn't give the prompt as
          long as you fed it arguments.

  3. Note that all commands defined using the `defcommand' syntax are
     available both to be called with `C-t ;' and from within other lisp
     programs, as though they had been defun-ned (which, in fact, they
     have).

  4. Any code that depends on external libraries or programs that some
     users might not have installed should be placed in the `contrib/'
     directory.

  5. Don't be afraid to submit your patches to the DSWM mailing list!
     It may not immediately make it into the official git repository,
     but individual users might find it useful and apply it to their
     own setup, or might be willing to offer suggestions on how to
     improve the code.

  6. Remember:  DSWM is designed to run on both clisp and on SBCL. If
     you must use code specific to one or the other, at the very least
     warn people that it only works with one lisp implementation.
     Better yet, figure out how to do it in the other distribution and
     write a statement like this:

          #+clisp
          (your-clisp-code)
          #+sbcl
          (your-sbcl-code)

     #to wrap the code for each lisp. Of course, the best option is to
     find a way to use the same code for clisp and SBCL.


File: dswm.info,  Node: Using git with DSWM,  Next: Sending Patches,  Prev: General Advice,  Up: Hacking

16.2 Hacking:  Using git with DSWM
==================================

For quite a while now, DSWM has been using the git version control
system for development. If you're one using one of the official
releases or still using the now-obsolete CVS version, you can get the
bleeding-edge source code from the official git repository with a
single command:

     $ git clone git://git.savannah.nongnu.org/dswm.git

   After this, you'll have a complete git repository, along with the
complete revision history since the switch. Feel free to play around;
git has some important features that actually make this safe!

   Before we get to that stuff, though, you're going to want to tell git
about yourself so that your information is included in your commits and
patches. The very minimum you're going to want to do is:

     $ git config --global user.name "Anne N. O'Nymous"
     $ git config --global user.email "anonymous@foo.org"

   Be sure to check out the manual for `git-config'-there are several
options you might want to set, such as enabling colorized output or
changing the editor and pager you use when making commits and viewing
logs.

   For the sake of argument, let's say you want to make some major
changes to both `user.lisp' and `core.lisp', add a file called
`DANGEROUS_EXPERIMENT_DO_NOT_USE_OR_ELSE.lisp', and remove the manual
because you're too 1337 for such things. However, you don't want to
break your entire DSWM setup and start over. Thankfully, you don't have
to. Before you get started, issue this command from the dswm directory:

     $ git checkout -b experimental

   You should now find yourself in a new branch, called experimental. To
confirm this, type `git branch'; there should be an asterisk next to
the branch you're currently viewing. At any time, you can type `git
checkout master' to return to your master branch, and at any time you
can have as many branches of the project as you like. If you want to
create a new branch based not on the master branch but on your
experimental branch, for example, you'd type:

     $ git checkout -b new-experiment experimental

   This will place you in a newly-created branch called "new-experiment"
which should be identical to your experimental branch as of the last
commit (more on that soon). If you're actually typing out the
directions, switch back to your old experimental branch like so:

     $ git checkout experimental

   Anyway, now that you have a new branch, create that new file with the
long name, which I'll just call `danger.lisp' for brevity. Make whatever
changes you want to it, and when you're done, tell git about your new
file.

     $ git add dangerous.lisp

   Now, let's pretend you're done making changes. Tell git you're done
for now:

     $ git commit -a

   This will open up a prompt in your editor of choice for you to
describe your changes. Try to keep the first line short, and then add
more explanation underneath (for an example, run the command `git log'
and take a look at some of the longer commit explanations). Save that
file and then do this:

     $ git checkout master
     $ ls

   Then look for your new file. It's not there! That's because you've
done all of your work in another branch, which git is currently hiding
from you so that you can "check out" the branch called "master." All is
as it should be-your master repository is still safe.

     $ git checkout experimental

   Now, delete `manual.lisp' and `dswm.texi'. That's right. Wipe them
off the face of the Earth, or at least off the hard drive of your
computer. When you're done, you don't have to tell git you've deleted
them; it'll figure it out on its own (though things may not compile
properly unless you edit `Makefile.in' and `dswm.asd'. Anyway, go ahead
and edit `core.lisp' and `user.lisp'. Really break 'em. Run free! When
you're done, do another commit, as above, and give it a stupid title
like "lolz i b0rked stUmpwm guys wTF!?!?!!111!" Now try to compile.
Just try. It won't work. If it does, you're some kind of savant or
something. Keep up the good work. If you've actually managed to break
DSWM like you were supposed to, never fear! You have two options at
this point.

   One is to go back to the master branch (with another git checkout)
and just delete your experimental branch, like so:

     $ git branch -D

   The "`-D'" means to force a delete, even if the changes you've made
aren't available elsewhere. A "`-d'" means to delete the branch if and
only if you've merged the changes in elsewhere.

   The other option is to create patches for each of your commits so
far, delete the branch, and then apply any working/wanted patches in a
new branch. Create your patches (after committing) like so:

     $ git format-patch -o patches origin

   (Before doing that you can review your changes with `git log
origin..')

   You can also use the `format-patch' command to create a patch of
working code to send in to the mailing list.

   A developer might ask you to try out something they're working on. To
fetch their master branch, you'd do this:

     $ git remote add -f -m master -t master foo git://bar.org/~foo/dswm

   Here, "foo" is the shorthand name you'll use to refer to that
repository in the future. To checkout a local copy of that repository,
you'd then do

     $ git checkout --track -b foo-master foo/master

   Later you could use `git pull foo' to update while looking at that
branch (and note that `git pull' with no arguments, in the master
branch, will update your DSWM from the official repository).

   Finally, if you want to move your experimental changes into your
master branch, you'd checkout your master branch and run:

     $ git merge experimental

   If there are file conflicts, `git diff' will show you where they are;
you have to fix them by hand. When you're done, do another

     $ git commit -a

   to finalize the changes to your master branch. You can then delete
your experimental branch. Alternately, you can wait until your changes
(assuming you sent them in) make it into the official repository before
deleting your experimental branch.


File: dswm.info,  Node: Sending Patches,  Prev: Using git with DSWM,  Up: Hacking

16.3 Sending Patches
====================

When sending patches to the mailing list for inclusion in DSWM, there
are a few guidelines that will make everything go smoother.

   * Make sure it applies clean to the main git repository

   * Ensure that you aren't introducing tabs, extra blank lines, or
     whitespace at the end of lines.

   * Ensure your patch doesn't contain irrelevant indenting or
     reformatting changes.

   * Try to make your patch address a single issue. If your patch
     changes two unrelated issues, break them into two seperate patches
     that can stand on their own.

   * Don't send intermediate patches. When you're working on a feature
     you might make several commits to your local repository as you
     refine it and work out the bugs. When it's polished and ready to
     ship, send it as one patch! Sometimes it makes sense to send it as
     multiple patches if each patch contains a discrete feature or bug
     fix that can stand on its own. If one of your patches changes code
     that was added or modified in an earlier patch, consider merging
     them together and sending them as one.



File: dswm.info,  Node: Command and Function Index,  Next: Variable Index,  Prev: Hacking,  Up: Top

Command and Function Index
**************************

 [index ]
* Menu:

* timer-p:                               Timers.               (line 11)


File: dswm.info,  Node: Variable Index,  Prev: Command and Function Index,  Up: Top

Variable Index
**************

 [index ]
* Menu:


Tag Table:
Node: Top1081
Node: Introduction2444
Node: Starting DSWM2858
Node: Basic Usage4095
Node: Interacting with the Lisp process6096
Node: Contact the DSWM developers6947
Node: Key Bindings7536
Node: List of Default Keybindings7868
Node: Binding Keys12592
Node: Modifiers12882
Node: Commands17447
Node: Message and Input Bar17881
Node: Customizing The Bar18162
Node: Using The Input Bar18634
Node: Programming The Message Bar20453
Node: Programming the Input Bar20748
Node: Windows21298
Node: Window Marks21949
Node: Customizing Window Appearance22268
Node: Controlling Raise And Map Requests22725
Node: Programming With Windows23777
Node: Rule Based Window Placement24056
Node: Frames24378
Node: Interactively Resizing Frames25120
Node: Frame Dumping25909
Node: Mode-line26259
Node: Groups28115
Node: Customizing Groups28581
Node: Screens28765
Node: Xinerama28995
Node: Programming With Screens29534
Node: Interacting With Unix29765
Node: Interacting With X1130046
Node: Miscellaneous Commands30251
Node: Menus31216
Node: DSWM's Data Directory31639
Node: Debugging DSWM32026
Node: Timers32243
Node: Getting Help32538
Node: Colors32748
Node: Behind The Scenes Look At Colors34302
Node: Hooks34978
Node: Modules35815
Node: Hacking36059
Node: General Advice36366
Node: Using git with DSWM39541
Node: Sending Patches45755
Node: Command and Function Index46984
Node: Variable Index47237

End Tag Table
